# 对象的管理

kubectl命令行工具支持几种不同的方式来创建和管理Kubernetes对象。 本文档概述了不同的方法。 阅读Kubectl书，了解Kubectl管理对象的详细信息。

## 管理技巧

警告：应该仅使用一种技术来管理Kubernetes对象。 同一对象的混合和匹配技术会导致不确定的行为。

管理技巧 | 操作对象 | 推荐环境 | 支持的作者 | 学习曲线
- | - | - | - | - 
命令式命令 | 实时对象 | 开发项目 | 多于1种 | 最低
命令式对象配置 | 单独文件 | 生产环境 | 1种 | 中等
声明式对象配置 | 文件夹 | 生产环境 | 多余1种 | 最高

## 命令式命令

使用命令式命令时，用户可以直接在集群中的活动对象上进行操作。 用户将对kubectl命令的操作作为参数或标志提供给用户。

这是在集群中开始或运行一次性任务的推荐方法。 因为此技术直接在活动对象上运行，所以它不提供先前配置的历史记录。

### 示例

通过创建Deployment对象来运行nginx容器的实例：

```code
kubectl create deployment nginx --image nginx
```

### 权衡取舍

与命令式对象配置相比的优势：
* 命令被表示为单个动作词。
* 命令仅需一步即可对集群进行更改。

与对象配置相比的缺点：
* 命令不与变更审查流程集成。
* 命令不提供与更改关联的审核跟踪。
* 除实时内容外，命令不提供记录源。
* 命令不提供用于创建新对象的模板。

## 命令式对象配置

在命令性对象配置中，kubectl命令指定操作（创建，替换等），可选标志和至少一个文件名。 指定的文件必须包含YAML或JSON格式的对象的完整定义。

警告：命令替换命令将现有规范替换为新提供的规范，并删除对配置文件中缺少的对象的所有更改。 此方法不应与规格独立于配置文件进行更新的资源类型一起使用。 例如，LoadBalancer类型的服务的externalIPs字段独立于集群的配置进行更新。

### 示例

创建定义在配置文件中的对象：
```code
kubectl create -f nginx.yaml
```

删除定义在2个配置文件中的对象：
```code
kubectl delete -f nginx.yaml -f redis.yaml
```

通过覆盖配置的方式更新定义在配置文件中的对象：
```code
kubectl replace -f nginx.yaml
```

### 权衡比较

相比命令交互式的优点如下：
* 对象的配置可以存放在源码控制系统例如git中
* 对象配置可以与流程集成，例如在推送和审计跟踪之前检查更改。
* 对象配置提供了用于创建新对象的模板。

相比于命令交互式的缺陷如下：
* 对象配置需要对对象架构有基本的了解。
* 对象配置需要额外的写入yaml文件的步骤。

相比于声明式配置的优点：
* 命令式对象配置行为更简单易懂。
* 从Kubernetes 1.5版开始，命令式对象配置更加成熟。

相比于声明式配置的缺点：
* 命令性对象配置最适合文件而不是目录。
* 对活动对象的更新必须反映在配置文件中，否则在下一次替换期间将丢失。

## 声明式配置

使用声明性对象配置时，用户对本地存储的对象配置文件进行操作，但是，用户未定义要对该文件执行的操作。 创建，更新和删除操作由kubectl自动检测到每个对象。 这样可以处理目录，其中不同的对象可能需要不同的操作。

注意：声明式对象配置保留其他编写者所做的更改，即使这些更改未合并回到对象配置文件中也是如此。 这可以通过使用补丁API操作仅写入观察到的差异，而不是使用replace API操作来替换整个对象配置来实现。


### 示例

处理configs目录中的所有对象配置文件，并创建或修补活动对象。 您可以先进行比较以查看将要进行的更改，然后应用：
```code
kubectl diff -f configs/
kubectl apply -f configs/
```

递归处理目录：
```code
kubectl diff -R -f configs/
kubectl apply -R -f configs/
```

### 权衡比较

相对于命令式对象配置的优点：
* 即使没有将它们直接合并回配置文件，也将保留直接对活动对象所做的更改。
* 声明性对象配置更好地支持对目录进行操作并自动检测每个对象的操作类型（创建，修补，删除）。

相对于命令式对象配置的缺点：
* 声明性对象配置在意外发生时更难调试和理解结果。
* 使用差异的部分更新会创建复杂的合并和补丁操作。