# 容器组

pods是kubernetes中创建和管理的最小单元。一个pod（正如豌豆一样），是一个或者多个容器的组合，它们共享存储和网络资源，以及运行容器的定义。一个pod的内容通常协同落地和协同调度，并且在共享的上下文中运行。一个pod的模版是一个应用的逻辑主机：它包含一个或者多个容器，这些容器紧密的耦合在一起。在非云环境中，在同一物理或虚拟机上执行的应用程序类似于在同一逻辑主机上执行的云应用程序。

正如应用容器一样，pod可以包含在启动时运行的初始化容器。如果集群提供该功能，你可以注入临时容器进行调试。

## 什么是pod

注意：尽管Kubernetes不仅支持Docker，还支持更多的容器运行时，但Docker是最常见的运行时，它有助于使用Docker中的一些术语来描述Pod。

Pod的共享上下文是一组Linux名称空间，cgroup和潜在的其他隔离方面-与隔离Docker容器相同。 在Pod的上下文中，各个应用程序可能还会应用其他子隔离。

就Docker概念而言，一个Pod类似于一组具有共享名称空间和共享文件系统卷的Docker容器。

## 使用pod

通常，您无需直接创建Pod，甚至无需创建Pod。 而是使用工作负荷资源（如“部署”或“作业”）创建它们。 如果您的Pod需要跟踪状态，请考虑使用StatefulSet资源。

kubernetes集群中pod主要有两种pod使用方式：
* pod运行单个容器，“每个容器一个容器”模型是最常见的Kubernetes用例。 在这种情况下，您可以将Pod视为单个容器的包装纸； Kubernetes管理Pod而不是直接管理容器。

*  运行多个需要协同工作的容器的Pod。 Pod可以封装一个应用程序，该应用程序由紧密关联且需要共享资源的多个位于同一地点的容器组成。 这些位于同一地点的容器形成一个单一的服务单元，例如，一个容器为公众提供存储在共享卷中的数据，而另一个独立的sidecar容器则刷新或更新这些文件。 Pod将这些容器，存储资源和临时网络标识包装为一个单元。

注意：在单个Pod中将多个位于同一地点和受共同管理的容器分组是一个相对高级的用例。 您仅应在容器紧密耦合的特定实例中使用此模式。

每个Pod旨在运行给定应用程序的单个实例。 如果要水平扩展应用程序（通过运行更多实例来提供更多整体资源），则应使用多个Pod，每个实例一个。 在Kubernetes中，这通常称为复制。 通常，工作负载资源及其控制器将复制的Pod作为一个组创建和管理。

有关Kubernetes如何使用工作负载资源及其控制器来实现应用程序扩展和自动修复的更多信息，请参见Pod和控制器。

## pod如何管理多个容器

Pod旨在支持形成协作服务单元的多个协作过程（作为容器）。 Pod中的容器会自动位于同一群集中的同一物理或虚拟机上，并在同一物理或虚拟机上进行共同调度。 这些容器可以共享资源和依赖关系，彼此通信，并协调何时以及如何终止它们。

例如，您可能有一个充当共享卷中文件的Web服务器的容器，以及一个单独的“ sidecar”容器，该容器从远程源更新这些文件，如下图所示：
![](https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg)

一些Pod具有init容器和app容器。 在启动应用程序容器之前，初始化容器会运行并完成。

Pod在本地为其组成容器提供两种共享资源：网络和存储。

## 使用pods

您很少会直接在Kubernetes中创建单个Pod，甚至是单独Pod。 这是因为Pod被设计为相对短暂的一次性实体。 当创建Pod（由您直接或由控制器间接创建）时，新的Pod计划在群集中的节点上运行。 Pod会保留在该节点上，直到Pod完成执行，删除Pod对象，由于缺少资源而将Pod逐出或节点发生故障为止。

注意：不要将重新启动Pod中的容器与重新启动Pod混淆。 Pod不是进程，而是用于运行容器的环境。 Pod一直存在直到被删除。

为Pod对象创建清单时，请确保指定的名称是有效的DNS子域名。

## pod与控制器

您可以使用工作负载资源为您创建和管理多个Pod。 资源的控制器处理Pod失败时的复制和推出以及自动修复。 例如，如果某个节点发生故障，则控制器会注意到该节点上的Pod已停止工作，并创建了一个替换Pod。 调度程序将替换的Pod放置到健康的节点上。

以下是管理一个或多个Pod的工作负载资源的一些示例：
* Deployment
* StatefulSet
* DaemonSet

## pod模版

工作负载资源的控制器从Pod模板创建Pod，并代表您管理这些Pod。

PodTemplates是用于创建Pod的规范，并且包含在工作负载资源（如Deployments，Jobs和DaemonSets）中。

工作负载资源的每个控制器都使用工作负载对象内的PodTemplate来创建实际的Pod。 PodTemplate是用于运行应用程序的任何工作负载资源的期望状态的一部分。

下面的示例是一个简单Job的清单，该Job具有一个模板，该模板开始一个容器。 该Pod中的容器会打印一条消息，然后暂停。

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # This is the pod template
    spec:
      containers:
      - name: hello
        image: busybox
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # The pod template ends here
```

修改Pod模板或切换到新的Pod模板不会对已经存在的Pod产生直接影响。如果更改工作负载资源的Pod模板，则该资源需要创建使用更新后的模板的替换Pod。

例如，StatefulSet控制器确保正在运行的Pod与每个StatefulSet对象的当前Pod模板匹配。如果您编辑StatefulSet以更改其窗格模板，则StatefulSet开始根据更新的模板创建新的Pod。最终，所有旧Pod被新Pod取代，更新完成。

每个工作负载资源都实现自己的规则，以处理Pod模板的更改。如果您想详细了解有关StatefulSet的更多信息，请阅读StatefulSet Basics教程中的更新策略。

在Nodes上，kubelet不会直接观察或管理有关Pod模板和更新的任何详细信息。这些细节被抽象掉了。关注点的抽象和分离简化了系统语义，并使得在不更改现有代码的情况下扩展集群的行为变得可行。

## pod的更新与替换

如上一节所述，当更改工作负载资源的Pod模板时，控制器将基于更新的模板创建新的Pod，而不是更新或修补现有Pod。

Kubernetes不会阻止您直接管理Pod。 可以就地更新正在运行的Pod的某些字段。 但是，Pod更新操作（例如补丁和替换）有一些限制：

* 大部分pod的元数据是不可变的。例如，你不可以修改namespace，name，uid和creationTimestamp字段，generation字段是唯一的，它仅仅接受来自当前值增长的更新。

* 如果metadata.deletionTimestamp设置了，不允许增加新的键值对到metadata.finalizers列表

* pod更新不会修改除了spec.containers[*].image，spec.initContainers[*].image, spec.activeDeadlineSeconds 或者 spec.tolerations字段；对于spec.tolerations，你仅可以增加新的键值对。

* 当更新spec.activeDeadlineSeconds字段时，允许两种类型的更新：
    1. 将未分配字段设置为正数；
    2. 将字段从正数更新为较小的非负数。

## 资源共享与交互

pod为容器间的数据共享与通信提供了能力。

### pod中的存储

Pod可以指定一组共享存储卷。 Pod中的所有容器都可以访问共享卷，从而使这些容器可以共享数据。 卷还允许Pod中的持久数据保留下来，以防其中的容器之一需要重新启动。 有关Kubernetes如何实现共享存储并将其提供给Pods的更多信息，请参见存储。

### pod中的网路

每个Pod为每个地址系列分配一个唯一的IP地址。 Pod中的每个容器都共享网络名称空间，包括IP地址和网络端口。 在Pod内部（并且只有那时），属于Pod的容器可以使用localhost相互通信。 当Pod中的容器与Pod外部的实体进行通信时，它们必须协调它们如何使用共享的网络资源（例如端口）。 在Pod中，容器共享一个IP地址和端口空间，并且可以通过本地主机相互查找。 Pod中的容器还可以使用标准的进程间通信（例如SystemV信号量或POSIX共享内存）相互通信。 不同Pod中的容器具有不同的IP地址，并且没有特殊配置就无法通过IPC进行通信。 想要与在其他Pod中运行的容器进行交互的容器可以使用IP网络进行通信。

Pod中的容器将系统主机名视为与Pod的配置名称相同。 在网络部分中有更多关于此的内容。

## 容器的特权模式

Pod中的任何容器都可以使用容器规范的安全上下文上的特权标志来启用特权模式。 这对于想要使用操作系统管理功能（如操纵网络堆栈或访问硬件设备）的容器很有用。 特权容器内的进程获得的特权几乎与容器外的进程相同。

注意：容器运行时必须支持特权容器的概念才能使此设置相关。

## 静态pods

静态Pod由特定节点上的kubelet守护程序直接管理，而API服务器不会对其进行观察。 尽管大多数Pod由控制平面（例如，部署）管理，但对于静态Pod，kubelet会直接监督每个静态Pod（如果失败，则将其重新启动）。

静态Pod始终绑定到特定节点上的一个Kubelet。 静态Pod的主要用途是运行一个自托管的控制平面：换句话说，使用kubelet来监督各个控制平面组件。

Kubelet会自动尝试在Kubernetes API服务器上为每个静态Pod创建一个镜像Pod。 这意味着在节点服务器上运行的Pod在API服务器上可见，但无法从该节点进行控制。

## 下一步

* 学习pod的[生命周期](pod-lifecycle.md)

